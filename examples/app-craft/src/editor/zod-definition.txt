declare namespace z {
    type IssueData = any;
    type ZodCustomIssue = any;
    type ZodErrorMap = any;
    // @ts-ignore
    type ZodError<T extends any = {}> = any;
    type ParseInput = any;
    // @ts-ignore
    type ParseReturnType<T> = any;
    type ParseStatus = any;
    type ParseContext = any;
    type Primitive = any;
    type ParseParams = any;

    // @ts-ignore
    type SyncParseReturnType<T> = any;
    // @ts-ignore
    type AsyncParseReturnType<T> = any;
    type StringValidation = any;
    namespace util {
        type Omit<T, B> = any;
        type noUndefined<T> = any;
        type Exactly<T, B> = any;
        export {Omit, noUndefined, Exactly}
    }

    namespace errorUtil {
        type ErrMessage = any;
        export {ErrMessage}
    }
    namespace objectUtil {
        type noNever<T> = any;
        type extendShape<T, B> = any;
        type flatten<T> = any;
        type addQuestionMarks<T,B extends object = {}> = any;
        export {noNever, extendShape, flatten, addQuestionMarks}
    }
    namespace partialUtil {
        type DeepPartial<T> = any;
        export {DeepPartial}
    }
    namespace enumUtil{
        type UnionToTupleString<T> = any;
        export {UnionToTupleString}
    }

    interface RefinementCtx {
        addIssue: (arg: IssueData) => void;
        path: (string | number)[];
    }

    type ZodRawShape = {
        [k: string]: ZodTypeAny;
    };
    type ZodTypeAny = ZodType<any, any, any>;
    type TypeOf<T extends ZodType<any, any, any>> = T["_output"];
    type input<T extends ZodType<any, any, any>> = T["_input"];
    type output<T extends ZodType<any, any, any>> = T["_output"];
    export type {TypeOf as infer};
    type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, "code">>;

    interface ZodTypeDef {
        errorMap?: ZodErrorMap;
        description?: string;
    }

    type RawCreateParams = {
        errorMap?: ZodErrorMap;
        invalid_type_error?: string;
        required_error?: string;
        message?: string;
        description?: string;
    } | undefined;
    type ProcessedCreateParams = {
        errorMap?: ZodErrorMap;
        description?: string;
    };
    type SafeParseSuccess<Output> = {
        success: true;
        data: Output;
        error?: never;
    };
    type SafeParseError<Input> = {
        success: false;
        error: ZodError<Input>;
        data?: never;
    };
    type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;

    abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {
        readonly _type: Output;
        readonly _output: Output;
        readonly _input: Input;
        readonly _def: Def;

        get description(): string | undefined;

        abstract _parse(input: ParseInput): ParseReturnType<Output>;

        _getType(input: ParseInput): string;

        _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext;

        _processInputParams(input: ParseInput): {
            status: ParseStatus;
            ctx: ParseContext;
        };

        _parseSync(input: ParseInput): SyncParseReturnType<Output>;

        _parseAsync(input: ParseInput): AsyncParseReturnType<Output>;

        parse(data: unknown, params?: Partial<ParseParams>): Output;

        safeParse(data: unknown, params?: Partial<ParseParams>): SafeParseReturnType<Input, Output>;

        parseAsync(data: unknown, params?: Partial<ParseParams>): Promise<Output>;

        safeParseAsync(data: unknown, params?: Partial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;

        spa: (data: unknown, params?: Partial<ParseParams> | undefined) => Promise<SafeParseReturnType<Input, Output>>;

        refine<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, RefinedOutput, Input>;
        refine(check: (arg: Output) => unknown | Promise<unknown>, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, Output, Input>;

        refinement<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, RefinedOutput, Input>;
        refinement(check: (arg: Output) => boolean, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, Output, Input>;

        _refinement(refinement: RefinementEffect<Output>["refinement"]): ZodEffects<this, Output, Input>;

        superRefine<RefinedOutput extends Output>(refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput): ZodEffects<this, RefinedOutput, Input>;
        superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;
        superRefine(refinement: (arg: Output, ctx: RefinementCtx) => Promise<void>): ZodEffects<this, Output, Input>;

        constructor(def: Def);

        optional(): ZodOptional<this>;

        nullable(): ZodNullable<this>;

        nullish(): ZodOptional<ZodNullable<this>>;

        array(): ZodArray<this>;

        promise(): ZodPromise<this>;

        or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]>;

        and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T>;

        transform<NewOut>(transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>): ZodEffects<this, NewOut>;

        default(def: util.noUndefined<Input>): ZodDefault<this>;
        default(def: () => util.noUndefined<Input>): ZodDefault<this>;

        brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;

        catch(def: Output): ZodCatch<this>;
        catch(def: (ctx: {
            error: ZodError;
            input: Input;
        }) => Output): ZodCatch<this>;

        describe(description: string): this;

        pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T>;

        readonly(): ZodReadonly<this>;

        isOptional(): boolean;

        isNullable(): boolean;
    }

    type IpVersion = "v4" | "v6";
    type ZodStringCheck = {
        kind: "min";
        value: number;
        message?: string;
    } | {
        kind: "max";
        value: number;
        message?: string;
    } | {
        kind: "length";
        value: number;
        message?: string;
    } | {
        kind: "email";
        message?: string;
    } | {
        kind: "url";
        message?: string;
    } | {
        kind: "emoji";
        message?: string;
    } | {
        kind: "uuid";
        message?: string;
    } | {
        kind: "nanoid";
        message?: string;
    } | {
        kind: "cuid";
        message?: string;
    } | {
        kind: "includes";
        value: string;
        position?: number;
        message?: string;
    } | {
        kind: "cuid2";
        message?: string;
    } | {
        kind: "ulid";
        message?: string;
    } | {
        kind: "startsWith";
        value: string;
        message?: string;
    } | {
        kind: "endsWith";
        value: string;
        message?: string;
    } | {
        kind: "regex";
        regex: RegExp;
        message?: string;
    } | {
        kind: "trim";
        message?: string;
    } | {
        kind: "toLowerCase";
        message?: string;
    } | {
        kind: "toUpperCase";
        message?: string;
    } | {
        kind: "datetime";
        offset: boolean;
        local: boolean;
        precision: number | null;
        message?: string;
    } | {
        kind: "date";
        message?: string;
    } | {
        kind: "time";
        precision: number | null;
        message?: string;
    } | {
        kind: "duration";
        message?: string;
    } | {
        kind: "ip";
        version?: IpVersion;
        message?: string;
    } | {
        kind: "base64";
        message?: string;
    };

    interface ZodStringDef extends ZodTypeDef {
        checks: ZodStringCheck[];
        typeName: ZodFirstPartyTypeKind.ZodString;
        coerce: boolean;
    }

    function datetimeRegex(args: {
        precision?: number | null;
        offset?: boolean;
        local?: boolean;
    }): RegExp;

    class ZodString extends ZodType<string, ZodStringDef, string> {
        _parse(input: ParseInput): ParseReturnType<string>;

        protected _regex(regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage): ZodEffects<this, string, string>;

        _addCheck(check: ZodStringCheck): ZodString;

        email(message?: errorUtil.ErrMessage): ZodString;

        url(message?: errorUtil.ErrMessage): ZodString;

        emoji(message?: errorUtil.ErrMessage): ZodString;

        uuid(message?: errorUtil.ErrMessage): ZodString;

        nanoid(message?: errorUtil.ErrMessage): ZodString;

        cuid(message?: errorUtil.ErrMessage): ZodString;

        cuid2(message?: errorUtil.ErrMessage): ZodString;

        ulid(message?: errorUtil.ErrMessage): ZodString;

        base64(message?: errorUtil.ErrMessage): ZodString;

        ip(options?: string | {
            version?: "v4" | "v6";
            message?: string;
        }): ZodString;

        datetime(options?: string | {
            message?: string | undefined;
            precision?: number | null;
            offset?: boolean;
            local?: boolean;
        }): ZodString;

        date(message?: string): ZodString;

        time(options?: string | {
            message?: string | undefined;
            precision?: number | null;
        }): ZodString;

        duration(message?: errorUtil.ErrMessage): ZodString;

        regex(regex: RegExp, message?: errorUtil.ErrMessage): ZodString;

        includes(value: string, options?: {
            message?: string;
            position?: number;
        }): ZodString;

        startsWith(value: string, message?: errorUtil.ErrMessage): ZodString;

        endsWith(value: string, message?: errorUtil.ErrMessage): ZodString;

        min(minLength: number, message?: errorUtil.ErrMessage): ZodString;

        max(maxLength: number, message?: errorUtil.ErrMessage): ZodString;

        length(len: number, message?: errorUtil.ErrMessage): ZodString;

        nonempty(message?: errorUtil.ErrMessage): ZodString;

        trim(): ZodString;

        toLowerCase(): ZodString;

        toUpperCase(): ZodString;

        get isDatetime(): boolean;

        get isDate(): boolean;

        get isTime(): boolean;

        get isDuration(): boolean;

        get isEmail(): boolean;

        get isURL(): boolean;

        get isEmoji(): boolean;

        get isUUID(): boolean;

        get isNANOID(): boolean;

        get isCUID(): boolean;

        get isCUID2(): boolean;

        get isULID(): boolean;

        get isIP(): boolean;

        get isBase64(): boolean;

        get minLength(): number | null;

        get maxLength(): number | null;

        static create: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: true | undefined;
        }) | undefined) => ZodString;
    }

    type ZodNumberCheck = {
        kind: "min";
        value: number;
        inclusive: boolean;
        message?: string;
    } | {
        kind: "max";
        value: number;
        inclusive: boolean;
        message?: string;
    } | {
        kind: "int";
        message?: string;
    } | {
        kind: "multipleOf";
        value: number;
        message?: string;
    } | {
        kind: "finite";
        message?: string;
    };

    interface ZodNumberDef extends ZodTypeDef {
        checks: ZodNumberCheck[];
        typeName: ZodFirstPartyTypeKind.ZodNumber;
        coerce: boolean;
    }

    class ZodNumber extends ZodType<number, ZodNumberDef, number> {
        _parse(input: ParseInput): ParseReturnType<number>;

        static create: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: boolean | undefined;
        }) | undefined) => ZodNumber;

        gte(value: number, message?: errorUtil.ErrMessage): ZodNumber;

        min: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;

        gt(value: number, message?: errorUtil.ErrMessage): ZodNumber;

        lte(value: number, message?: errorUtil.ErrMessage): ZodNumber;

        max: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;

        lt(value: number, message?: errorUtil.ErrMessage): ZodNumber;

        protected setLimit(kind: "min" | "max", value: number, inclusive: boolean, message?: string): ZodNumber;

        _addCheck(check: ZodNumberCheck): ZodNumber;

        int(message?: errorUtil.ErrMessage): ZodNumber;

        positive(message?: errorUtil.ErrMessage): ZodNumber;

        negative(message?: errorUtil.ErrMessage): ZodNumber;

        nonpositive(message?: errorUtil.ErrMessage): ZodNumber;

        nonnegative(message?: errorUtil.ErrMessage): ZodNumber;

        multipleOf(value: number, message?: errorUtil.ErrMessage): ZodNumber;

        step: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;

        finite(message?: errorUtil.ErrMessage): ZodNumber;

        safe(message?: errorUtil.ErrMessage): ZodNumber;

        get minValue(): number | null;

        get maxValue(): number | null;

        get isInt(): boolean;

        get isFinite(): boolean;
    }

    type ZodBigIntCheck = {
        kind: "min";
        value: bigint;
        inclusive: boolean;
        message?: string;
    } | {
        kind: "max";
        value: bigint;
        inclusive: boolean;
        message?: string;
    } | {
        kind: "multipleOf";
        value: bigint;
        message?: string;
    };

    interface ZodBigIntDef extends ZodTypeDef {
        checks: ZodBigIntCheck[];
        typeName: ZodFirstPartyTypeKind.ZodBigInt;
        coerce: boolean;
    }

    class ZodBigInt extends ZodType<bigint, ZodBigIntDef, bigint> {
        _parse(input: ParseInput): ParseReturnType<bigint>;

        static create: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: boolean | undefined;
        }) | undefined) => ZodBigInt;

        gte(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;

        min: (value: bigint, message?: errorUtil.ErrMessage | undefined) => ZodBigInt;

        gt(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;

        lte(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;

        max: (value: bigint, message?: errorUtil.ErrMessage | undefined) => ZodBigInt;

        lt(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;

        protected setLimit(kind: "min" | "max", value: bigint, inclusive: boolean, message?: string): ZodBigInt;

        _addCheck(check: ZodBigIntCheck): ZodBigInt;

        positive(message?: errorUtil.ErrMessage): ZodBigInt;

        negative(message?: errorUtil.ErrMessage): ZodBigInt;

        nonpositive(message?: errorUtil.ErrMessage): ZodBigInt;

        nonnegative(message?: errorUtil.ErrMessage): ZodBigInt;

        multipleOf(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;

        get minValue(): bigint | null;

        get maxValue(): bigint | null;
    }

    interface ZodBooleanDef extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodBoolean;
        coerce: boolean;
    }

    class ZodBoolean extends ZodType<boolean, ZodBooleanDef, boolean> {
        _parse(input: ParseInput): ParseReturnType<boolean>;

        static create: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: boolean | undefined;
        }) | undefined) => ZodBoolean;
    }

    type ZodDateCheck = {
        kind: "min";
        value: number;
        message?: string;
    } | {
        kind: "max";
        value: number;
        message?: string;
    };

    interface ZodDateDef extends ZodTypeDef {
        checks: ZodDateCheck[];
        coerce: boolean;
        typeName: ZodFirstPartyTypeKind.ZodDate;
    }

    class ZodDate extends ZodType<Date, ZodDateDef, Date> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        _addCheck(check: ZodDateCheck): ZodDate;

        min(minDate: Date, message?: errorUtil.ErrMessage): ZodDate;

        max(maxDate: Date, message?: errorUtil.ErrMessage): ZodDate;

        get minDate(): Date | null;

        get maxDate(): Date | null;

        static create: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: boolean | undefined;
        }) | undefined) => ZodDate;
    }

    interface ZodSymbolDef extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodSymbol;
    }

    class ZodSymbol extends ZodType<symbol, ZodSymbolDef, symbol> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: (params?: RawCreateParams) => ZodSymbol;
    }

    interface ZodUndefinedDef extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodUndefined;
    }

    class ZodUndefined extends ZodType<undefined, ZodUndefinedDef, undefined> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        params?: RawCreateParams;
        static create: (params?: RawCreateParams) => ZodUndefined;
    }

    interface ZodNullDef extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodNull;
    }

    class ZodNull extends ZodType<null, ZodNullDef, null> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: (params?: RawCreateParams) => ZodNull;
    }

    interface ZodAnyDef extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodAny;
    }

    class ZodAny extends ZodType<any, ZodAnyDef, any> {
        _any: true;

        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: (params?: RawCreateParams) => ZodAny;
    }

    interface ZodUnknownDef extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodUnknown;
    }

    class ZodUnknown extends ZodType<unknown, ZodUnknownDef, unknown> {
        _unknown: true;

        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: (params?: RawCreateParams) => ZodUnknown;
    }

    interface ZodNeverDef extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodNever;
    }

    class ZodNever extends ZodType<never, ZodNeverDef, never> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: (params?: RawCreateParams) => ZodNever;
    }

    interface ZodVoidDef extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodVoid;
    }

    class ZodVoid extends ZodType<void, ZodVoidDef, void> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: (params?: RawCreateParams) => ZodVoid;
    }

    interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        type: T;
        typeName: ZodFirstPartyTypeKind.ZodArray;
        exactLength: {
            value: number;
            message?: string;
        } | null;
        minLength: {
            value: number;
            message?: string;
        } | null;
        maxLength: {
            value: number;
            message?: string;
        } | null;
    }

    type ArrayCardinality = "many" | "atleastone";
    type arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> = Cardinality extends "atleastone" ? [T["_output"], ...T["_output"][]] : T["_output"][];

    class ZodArray<T extends ZodTypeAny, Cardinality extends ArrayCardinality = "many"> extends ZodType<arrayOutputType<T, Cardinality>, ZodArrayDef<T>, Cardinality extends "atleastone" ? [T["_input"], ...T["_input"][]] : T["_input"][]> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        get element(): T;

        min(minLength: number, message?: errorUtil.ErrMessage): this;

        max(maxLength: number, message?: errorUtil.ErrMessage): this;

        length(len: number, message?: errorUtil.ErrMessage): this;

        nonempty(message?: errorUtil.ErrMessage): ZodArray<T, "atleastone">;

        static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodArray<T_1, "many">;
    }

    type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, "atleastone">;
    type UnknownKeysParam = "passthrough" | "strict" | "strip";

    interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodObject;
        shape: () => T;
        catchall: Catchall;
        unknownKeys: UnknownKeys;
    }

    type mergeTypes<A, B> = {
        [k in keyof A | keyof B]: k extends keyof B ? B[k] : k extends keyof A ? A[k] : never;
    };
    type objectOutputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> =
        objectUtil.flatten<objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>>
        & CatchallOutput<Catchall>
        & PassthroughType<UnknownKeys>;
    type baseObjectOutputType<Shape extends ZodRawShape> = {
        [k in keyof Shape]: Shape[k]["_output"];
    };
    type objectInputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> =
        objectUtil.flatten<baseObjectInputType<Shape>>
        & CatchallInput<Catchall>
        & PassthroughType<UnknownKeys>;
    type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.addQuestionMarks<{
        [k in keyof Shape]: Shape[k]["_input"];
    }>;
    type CatchallOutput<T extends ZodType> = ZodType extends T ? unknown : {
        [k: string]: T["_output"];
    };
    type CatchallInput<T extends ZodType> = ZodType extends T ? unknown : {
        [k: string]: T["_input"];
    };
    type PassthroughType<T extends UnknownKeysParam> = T extends "passthrough" ? {
        [k: string]: unknown;
    } : unknown;
    type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T extends ZodNullable<infer U> ? ZodNullable<deoptional<U>> : T;
    type SomeZodObject = ZodObject<ZodRawShape, UnknownKeysParam, ZodTypeAny>;
    type noUnrecognized<Obj extends object, Shape extends object> = {
        [k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;
    };

    class ZodObject<T extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny, Output = objectOutputType<T, Catchall, UnknownKeys>, Input = objectInputType<T, Catchall, UnknownKeys>> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {
        private _cached;

        _getCached(): {
            shape: T;
            keys: string[];
        };

        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        get shape(): T;

        strict(message?: errorUtil.ErrMessage): ZodObject<T, "strict", Catchall>;

        strip(): ZodObject<T, "strip", Catchall>;

        passthrough(): ZodObject<T, "passthrough", Catchall>;

        nonstrict: () => ZodObject<T, "passthrough", Catchall>;

        extend<Augmentation extends ZodRawShape>(augmentation: Augmentation): ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;

        augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall, objectOutputType<objectUtil.extendShape<T, Augmentation>, Catchall, UnknownKeys>, objectInputType<objectUtil.extendShape<T, Augmentation>, Catchall, UnknownKeys>>;

        merge<Incoming extends AnyZodObject, Augmentation extends Incoming["shape"]>(merging: Incoming): ZodObject<objectUtil.extendShape<T, Augmentation>, Incoming["_def"]["unknownKeys"], Incoming["_def"]["catchall"]>;

        setKey<Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema): ZodObject<T & {
            [k in Key]: Schema;
        }, UnknownKeys, Catchall>;

        catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index>;

        pick<Mask extends util.Exactly<{
            [k in keyof T]?: true;
        }, Mask>>(mask: Mask): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;

        omit<Mask extends util.Exactly<{
            [k in keyof T]?: true;
        }, Mask>>(mask: Mask): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall>;

        deepPartial(): partialUtil.DeepPartial<this>;

        partial(): ZodObject<{
            [k in keyof T]: ZodOptional<T[k]>;
        }, UnknownKeys, Catchall>;
        partial<Mask extends util.Exactly<{
            [k in keyof T]?: true;
        }, Mask>>(mask: Mask): ZodObject<objectUtil.noNever<{
            [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];
        }>, UnknownKeys, Catchall>;

        required(): ZodObject<{
            [k in keyof T]: deoptional<T[k]>;
        }, UnknownKeys, Catchall>;
        required<Mask extends util.Exactly<{
            [k in keyof T]?: true;
        }, Mask>>(mask: Mask): ZodObject<objectUtil.noNever<{
            [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];
        }>, UnknownKeys, Catchall>;

        keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>>;

        static create: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strip", ZodTypeAny, { [k in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>[k]; }, { [k_1 in keyof baseObjectInputType<T_1>]: baseObjectInputType<T_1>[k_1]; }>;
        static strictCreate: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, "strict", ZodTypeAny, { [k in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>[k]; }, { [k_1 in keyof baseObjectInputType<T_1>]: baseObjectInputType<T_1>[k_1]; }>;
        static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1, params?: RawCreateParams) => ZodObject<T_1, "strip", ZodTypeAny, { [k in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, any>[k]; }, { [k_1 in keyof baseObjectInputType<T_1>]: baseObjectInputType<T_1>[k_1]; }>;
    }

    type AnyZodObject = ZodObject<any, any, any>;
    type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;

    interface ZodUnionDef<T extends ZodUnionOptions = Readonly<[
        ZodTypeAny,
        ZodTypeAny,
        ...ZodTypeAny[]
    ]>> extends ZodTypeDef {
        options: T;
        typeName: ZodFirstPartyTypeKind.ZodUnion;
    }

    class ZodUnion<T extends ZodUnionOptions> extends ZodType<T[number]["_output"], ZodUnionDef<T>, T[number]["_input"]> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        get options(): T;

        static create: <T_1 extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T_1, params?: RawCreateParams) => ZodUnion<T_1>;
    }

    type ZodDiscriminatedUnionOption<Discriminator extends string> = ZodObject<{
        [key in Discriminator]: ZodTypeAny;
    } & ZodRawShape, UnknownKeysParam, ZodTypeAny>;

    interface ZodDiscriminatedUnionDef<Discriminator extends string, Options extends ZodDiscriminatedUnionOption<string>[] = ZodDiscriminatedUnionOption<string>[]> extends ZodTypeDef {
        discriminator: Discriminator;
        options: Options;
        optionsMap: Map<Primitive, ZodDiscriminatedUnionOption<any>>;
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;
    }

    class ZodDiscriminatedUnion<Discriminator extends string, Options extends ZodDiscriminatedUnionOption<Discriminator>[]> extends ZodType<output<Options[number]>, ZodDiscriminatedUnionDef<Discriminator, Options>, input<Options[number]>> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        get discriminator(): Discriminator;

        get options(): Options;

        get optionsMap(): Map<Primitive, ZodDiscriminatedUnionOption<any>>;

        static create<Discriminator extends string, Types extends [
            ZodDiscriminatedUnionOption<Discriminator>,
            ...ZodDiscriminatedUnionOption<Discriminator>[]
        ]>(discriminator: Discriminator, options: Types, params?: RawCreateParams): ZodDiscriminatedUnion<Discriminator, Types>;
    }

    interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        left: T;
        right: U;
        typeName: ZodFirstPartyTypeKind.ZodIntersection;
    }

    class ZodIntersection<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType<T["_output"] & U["_output"], ZodIntersectionDef<T, U>, T["_input"] & U["_input"]> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: <T_1 extends ZodTypeAny, U_1 extends ZodTypeAny>(left: T_1, right: U_1, params?: RawCreateParams) => ZodIntersection<T_1, U_1>;
    }

    type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];
    type AssertArray<T> = T extends any[] ? T : never;
    type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
        [k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k]["_output"] : never;
    }>;
    type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest["_output"][]] : OutputTypeOfTuple<T>;
    type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{
        [k in keyof T]: T[k] extends ZodType<any, any, any> ? T[k]["_input"] : never;
    }>;
    type InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest["_input"][]] : InputTypeOfTuple<T>;

    interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodTypeDef {
        items: T;
        rest: Rest;
        typeName: ZodFirstPartyTypeKind.ZodTuple;
    }

    type AnyZodTuple = ZodTuple<[
        ZodTypeAny,
        ...ZodTypeAny[]
    ] | [], ZodTypeAny | null>;

    class ZodTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]], Rest extends ZodTypeAny | null = null> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        get items(): T;

        rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest>;

        static create: <T_1 extends [] | [ZodTypeAny, ...ZodTypeAny[]]>(schemas: T_1, params?: RawCreateParams) => ZodTuple<T_1, null>;
    }

    interface ZodRecordDef<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        valueType: Value;
        keyType: Key;
        typeName: ZodFirstPartyTypeKind.ZodRecord;
    }

    type KeySchema = ZodType<string | number | symbol, any, any>;
    type RecordType<K extends string | number | symbol, V> = [
        string
    ] extends [K] ? Record<K, V> : [number] extends [K] ? Record<K, V> : [symbol] extends [K] ? Record<K, V> : [BRAND<string | number | symbol>] extends [K] ? Record<K, V> : Partial<Record<K, V>>;

    class ZodRecord<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<RecordType<Key["_output"], Value["_output"]>, ZodRecordDef<Key, Value>, RecordType<Key["_input"], Value["_input"]>> {
        get keySchema(): Key;

        get valueSchema(): Value;

        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        get element(): Value;

        static create<Value extends ZodTypeAny>(valueType: Value, params?: RawCreateParams): ZodRecord<ZodString, Value>;
        static create<Keys extends KeySchema, Value extends ZodTypeAny>(keySchema: Keys, valueType: Value, params?: RawCreateParams): ZodRecord<Keys, Value>;
    }

    interface ZodMapDef<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        valueType: Value;
        keyType: Key;
        typeName: ZodFirstPartyTypeKind.ZodMap;
    }

    class ZodMap<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Map<Key["_output"], Value["_output"]>, ZodMapDef<Key, Value>, Map<Key["_input"], Value["_input"]>> {
        get keySchema(): Key;

        get valueSchema(): Value;

        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: <Key_1 extends ZodTypeAny = ZodTypeAny, Value_1 extends ZodTypeAny = ZodTypeAny>(keyType: Key_1, valueType: Value_1, params?: RawCreateParams) => ZodMap<Key_1, Value_1>;
    }

    interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        valueType: Value;
        typeName: ZodFirstPartyTypeKind.ZodSet;
        minSize: {
            value: number;
            message?: string;
        } | null;
        maxSize: {
            value: number;
            message?: string;
        } | null;
    }

    class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Set<Value["_output"]>, ZodSetDef<Value>, Set<Value["_input"]>> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        min(minSize: number, message?: errorUtil.ErrMessage): this;

        max(maxSize: number, message?: errorUtil.ErrMessage): this;

        size(size: number, message?: errorUtil.ErrMessage): this;

        nonempty(message?: errorUtil.ErrMessage): ZodSet<Value>;

        static create: <Value_1 extends ZodTypeAny = ZodTypeAny>(valueType: Value_1, params?: RawCreateParams) => ZodSet<Value_1>;
    }

    interface ZodFunctionDef<Args extends ZodTuple<any, any> = ZodTuple<any, any>, Returns extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        args: Args;
        returns: Returns;
        typeName: ZodFirstPartyTypeKind.ZodFunction;
    }

    type OuterTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args["_input"] extends Array<any> ? (...args: Args["_input"]) => Returns["_output"] : never;
    type InnerTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args["_output"] extends Array<any> ? (...args: Args["_output"]) => Returns["_input"] : never;

    class ZodFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> extends ZodType<OuterTypeOfFunction<Args, Returns>, ZodFunctionDef<Args, Returns>, InnerTypeOfFunction<Args, Returns>> {
        _parse(input: ParseInput): ParseReturnType<any>;

        parameters(): Args;

        returnType(): Returns;

        args<Items extends Parameters<(typeof ZodTuple)["create"]>[0]>(...items: Items): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns>;

        returns<NewReturnType extends ZodType<any, any, any>>(returnType: NewReturnType): ZodFunction<Args, NewReturnType>;

        implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): ReturnType<F> extends Returns["_output"] ? (...args: Args["_input"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;

        strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns>;

        validate: <F extends InnerTypeOfFunction<Args, Returns>>(func: F) => ReturnType<F> extends Returns["_output"] ? (...args: Args["_input"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;

        static create(): ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>;
        static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>>(args: T): ZodFunction<T, ZodUnknown>;
        static create<T extends AnyZodTuple, U extends ZodTypeAny>(args: T, returns: U): ZodFunction<T, U>;
        static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>, U extends ZodTypeAny = ZodUnknown>(args: T, returns: U, params?: RawCreateParams): ZodFunction<T, U>;
    }

    interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        getter: () => T;
        typeName: ZodFirstPartyTypeKind.ZodLazy;
    }

    class ZodLazy<T extends ZodTypeAny> extends ZodType<output<T>, ZodLazyDef<T>, input<T>> {
        get schema(): T;

        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: <T_1 extends ZodTypeAny>(getter: () => T_1, params?: RawCreateParams) => ZodLazy<T_1>;
    }

    interface ZodLiteralDef<T = any> extends ZodTypeDef {
        value: T;
        typeName: ZodFirstPartyTypeKind.ZodLiteral;
    }

    class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>, T> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        get value(): T;

        static create: <T_1 extends Primitive>(value: T_1, params?: RawCreateParams) => ZodLiteral<T_1>;
    }

    type ArrayKeys = keyof any[];
    type Indices<T> = Exclude<keyof T, ArrayKeys>;
    type EnumValues<T extends string = string> = readonly [T, ...T[]];
    type Values<T extends EnumValues> = {
        [k in T[number]]: k;
    };

    interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {
        values: T;
        typeName: ZodFirstPartyTypeKind.ZodEnum;
    }

    type Writeable<T> = {
        -readonly [P in keyof T]: T[P];
    };
    type FilterEnum<Values, ToExclude> = Values extends [] ? [] : Values extends [infer Head, ...infer Rest] ? Head extends ToExclude ? FilterEnum<Rest, ToExclude> : [Head, ...FilterEnum<Rest, ToExclude>] : never;
    type typecast<A, T> = A extends T ? A : never;

    function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;
    function createZodEnum<U extends string, T extends [U, ...U[]]>(values: T, params?: RawCreateParams): ZodEnum<T>;

    class ZodEnum<T extends [string, ...string[]]> extends ZodType<T[number], ZodEnumDef<T>, T[number]> {
        #private;

        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        get options(): T;

        get enum(): Values<T>;

        get Values(): Values<T>;

        get Enum(): Values<T>;

        extract<ToExtract extends readonly [T[number], ...T[number][]]>(values: ToExtract, newDef?: RawCreateParams): ZodEnum<Writeable<ToExtract>>;

        exclude<ToExclude extends readonly [T[number], ...T[number][]]>(values: ToExclude, newDef?: RawCreateParams): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [string, ...string[]]>>;

        static create: typeof createZodEnum;
    }

    interface ZodNativeEnumDef<T extends EnumLike = EnumLike> extends ZodTypeDef {
        values: T;
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum;
    }

    type EnumLike = {
        [k: string]: string | number;
        [nu: number]: string;
    };

    class ZodNativeEnum<T extends EnumLike> extends ZodType<T[keyof T], ZodNativeEnumDef<T>, T[keyof T]> {
        #private;

        _parse(input: ParseInput): ParseReturnType<T[keyof T]>;

        get enum(): T;

        static create: <T_1 extends EnumLike>(values: T_1, params?: RawCreateParams) => ZodNativeEnum<T_1>;
    }

    interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        type: T;
        typeName: ZodFirstPartyTypeKind.ZodPromise;
    }

    class ZodPromise<T extends ZodTypeAny> extends ZodType<Promise<T["_output"]>, ZodPromiseDef<T>, Promise<T["_input"]>> {
        unwrap(): T;

        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodPromise<T_1>;
    }

    type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;
    type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void | Promise<void>;
    type RefinementEffect<T> = {
        type: "refinement";
        refinement: (arg: T, ctx: RefinementCtx) => any;
    };
    type TransformEffect<T> = {
        type: "transform";
        transform: (arg: T, ctx: RefinementCtx) => any;
    };
    type PreprocessEffect<T> = {
        type: "preprocess";
        transform: (arg: T, ctx: RefinementCtx) => any;
    };
    type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;

    interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        schema: T;
        typeName: ZodFirstPartyTypeKind.ZodEffects;
        effect: Effect<any>;
    }

    class ZodEffects<T extends ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<Output, ZodEffectsDef<T>, Input> {
        innerType(): T;

        sourceType(): T;

        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: <I extends ZodTypeAny>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"], input<I>>;
        static createWithPreprocess: <I extends ZodTypeAny>(preprocess: (arg: unknown, ctx: RefinementCtx) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
    }

    export {ZodEffects as ZodTransformer};

    interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        innerType: T;
        typeName: ZodFirstPartyTypeKind.ZodOptional;
    }

    type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;

    class ZodOptional<T extends ZodTypeAny> extends ZodType<T["_output"] | undefined, ZodOptionalDef<T>, T["_input"] | undefined> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        unwrap(): T;

        static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodOptional<T_1>;
    }

    interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        innerType: T;
        typeName: ZodFirstPartyTypeKind.ZodNullable;
    }

    type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;

    class ZodNullable<T extends ZodTypeAny> extends ZodType<T["_output"] | null, ZodNullableDef<T>, T["_input"] | null> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        unwrap(): T;

        static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodNullable<T_1>;
    }

    interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        innerType: T;
        defaultValue: () => util.noUndefined<T["_input"]>;
        typeName: ZodFirstPartyTypeKind.ZodDefault;
    }

    class ZodDefault<T extends ZodTypeAny> extends ZodType<util.noUndefined<T["_output"]>, ZodDefaultDef<T>, T["_input"] | undefined> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        removeDefault(): T;

        static create: <T_1 extends ZodTypeAny>(type: T_1, params: {
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            default: T_1["_input"] | (() => util.noUndefined<T_1["_input"]>);
        }) => ZodDefault<T_1>;
    }

    interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        innerType: T;
        catchValue: (ctx: {
            error: ZodError;
            input: unknown;
        }) => T["_input"];
        typeName: ZodFirstPartyTypeKind.ZodCatch;
    }

    class ZodCatch<T extends ZodTypeAny> extends ZodType<T["_output"], ZodCatchDef<T>, unknown> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        removeCatch(): T;

        static create: <T_1 extends ZodTypeAny>(type: T_1, params: {
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            catch: T_1["_output"] | (() => T_1["_output"]);
        }) => ZodCatch<T_1>;
    }

    interface ZodNaNDef extends ZodTypeDef {
        typeName: ZodFirstPartyTypeKind.ZodNaN;
    }

    class ZodNaN extends ZodType<number, ZodNaNDef, number> {
        _parse(input: ParseInput): ParseReturnType<any>;

        static create: (params?: RawCreateParams) => ZodNaN;
    }

    interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {
        type: T;
        typeName: ZodFirstPartyTypeKind.ZodBranded;
    }

    const BRAND: unique symbol;
    type BRAND<T extends string | number | symbol> = {
        [BRAND]: {
            [k in T]: true;
        };
    };

    class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<T["_output"] & BRAND<B>, ZodBrandedDef<T>, T["_input"]> {
        _parse(input: ParseInput): ParseReturnType<any>;

        unwrap(): T;
    }

    interface ZodPipelineDef<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodTypeDef {
        in: A;
        out: B;
        typeName: ZodFirstPartyTypeKind.ZodPipeline;
    }

    class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType<B["_output"], ZodPipelineDef<A, B>, A["_input"]> {
        _parse(input: ParseInput): ParseReturnType<any>;

        static create<A extends ZodTypeAny, B extends ZodTypeAny>(a: A, b: B): ZodPipeline<A, B>;
    }

    type BuiltIn = (((...args: any[]) => any) | (new (...args: any[]) => any)) | {
        readonly [Symbol.toStringTag]: string;
    } | Date | Error | Generator | Promise<unknown> | RegExp;
    type MakeReadonly<T> = T extends Map<infer K, infer V> ? ReadonlyMap<K, V> : T extends Set<infer V> ? ReadonlySet<V> : T extends [infer Head, ...infer Tail] ? readonly [Head, ...Tail] : T extends Array<infer V> ? ReadonlyArray<V> : T extends BuiltIn ? T : Readonly<T>;

    interface ZodReadonlyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {
        innerType: T;
        typeName: ZodFirstPartyTypeKind.ZodReadonly;
    }

    class ZodReadonly<T extends ZodTypeAny> extends ZodType<MakeReadonly<T["_output"]>, ZodReadonlyDef<T>, MakeReadonly<T["_input"]>> {
        _parse(input: ParseInput): ParseReturnType<this["_output"]>;

        static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodReadonly<T_1>;

        unwrap(): T;
    }

    type CustomParams = CustomErrorParams & {
        fatal?: boolean;
    };

    function custom<T>(check?: (data: any) => any, params?: string | CustomParams | ((input: any) => CustomParams), fatal?: boolean): ZodType<T, ZodTypeDef, T>;

    export {ZodType as Schema, ZodType as ZodSchema};
    const late: {
        object: <T extends ZodRawShape>(shape: () => T, params?: RawCreateParams) => ZodObject<T, "strip", ZodTypeAny, { [k in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T>, any>]: objectUtil.addQuestionMarks<baseObjectOutputType<T>, any>[k]; }, { [k_1 in keyof baseObjectInputType<T>]: baseObjectInputType<T>[k_1]; }>;
    };

    enum ZodFirstPartyTypeKind {
        ZodString = "ZodString",
        ZodNumber = "ZodNumber",
        ZodNaN = "ZodNaN",
        ZodBigInt = "ZodBigInt",
        ZodBoolean = "ZodBoolean",
        ZodDate = "ZodDate",
        ZodSymbol = "ZodSymbol",
        ZodUndefined = "ZodUndefined",
        ZodNull = "ZodNull",
        ZodAny = "ZodAny",
        ZodUnknown = "ZodUnknown",
        ZodNever = "ZodNever",
        ZodVoid = "ZodVoid",
        ZodArray = "ZodArray",
        ZodObject = "ZodObject",
        ZodUnion = "ZodUnion",
        ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
        ZodIntersection = "ZodIntersection",
        ZodTuple = "ZodTuple",
        ZodRecord = "ZodRecord",
        ZodMap = "ZodMap",
        ZodSet = "ZodSet",
        ZodFunction = "ZodFunction",
        ZodLazy = "ZodLazy",
        ZodLiteral = "ZodLiteral",
        ZodEnum = "ZodEnum",
        ZodEffects = "ZodEffects",
        ZodNativeEnum = "ZodNativeEnum",
        ZodOptional = "ZodOptional",
        ZodNullable = "ZodNullable",
        ZodDefault = "ZodDefault",
        ZodCatch = "ZodCatch",
        ZodPromise = "ZodPromise",
        ZodBranded = "ZodBranded",
        ZodPipeline = "ZodPipeline",
        ZodReadonly = "ZodReadonly"
    }

    type ZodFirstPartySchemaTypes =
        ZodString
        | ZodNumber
        | ZodNaN
        | ZodBigInt
        | ZodBoolean
        | ZodDate
        | ZodUndefined
        | ZodNull
        | ZodAny
        | ZodUnknown
        | ZodNever
        | ZodVoid
        | ZodArray<any, any>
        | ZodObject<any, any, any>
        | ZodUnion<any>
        | ZodDiscriminatedUnion<any, any>
        | ZodIntersection<any, any>
        | ZodTuple<any, any>
        | ZodRecord<any, any>
        | ZodMap<any>
        | ZodSet<any>
        | ZodFunction<any, any>
        | ZodLazy<any>
        | ZodLiteral<any>
        | ZodEnum<any>
        | ZodEffects<any, any, any>
        | ZodNativeEnum<any>
        | ZodOptional<any>
        | ZodNullable<any>
        | ZodDefault<any>
        | ZodCatch<any>
        | ZodPromise<any>
        | ZodBranded<any, any>
        | ZodPipeline<any, any>
        | ZodReadonly<any>
        | ZodSymbol;

    abstract class Class {
        constructor(..._: any[]);
    }

    const instanceOfType: <T extends typeof Class>(cls: T, params?: CustomParams) => ZodType<InstanceType<T>, ZodTypeDef, InstanceType<T>>;
    const stringType: (params?: ({
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        message?: string | undefined;
        description?: string | undefined;
    } & {
        coerce?: true | undefined;
    }) | undefined) => ZodString;
    const numberType: (params?: ({
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        message?: string | undefined;
        description?: string | undefined;
    } & {
        coerce?: boolean | undefined;
    }) | undefined) => ZodNumber;
    const nanType: (params?: RawCreateParams) => ZodNaN;
    const bigIntType: (params?: ({
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        message?: string | undefined;
        description?: string | undefined;
    } & {
        coerce?: boolean | undefined;
    }) | undefined) => ZodBigInt;
    const booleanType: (params?: ({
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        message?: string | undefined;
        description?: string | undefined;
    } & {
        coerce?: boolean | undefined;
    }) | undefined) => ZodBoolean;
    const dateType: (params?: ({
        errorMap?: ZodErrorMap | undefined;
        invalid_type_error?: string | undefined;
        required_error?: string | undefined;
        message?: string | undefined;
        description?: string | undefined;
    } & {
        coerce?: boolean | undefined;
    }) | undefined) => ZodDate;
    const symbolType: (params?: RawCreateParams) => ZodSymbol;
    const undefinedType: (params?: RawCreateParams) => ZodUndefined;
    const nullType: (params?: RawCreateParams) => ZodNull;
    const anyType: (params?: RawCreateParams) => ZodAny;
    const unknownType: (params?: RawCreateParams) => ZodUnknown;
    const neverType: (params?: RawCreateParams) => ZodNever;
    const voidType: (params?: RawCreateParams) => ZodVoid;
    const arrayType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodArray<T, "many">;
    const objectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, "strip", ZodTypeAny, { [k in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T>, any>]: objectUtil.addQuestionMarks<baseObjectOutputType<T>, any>[k]; }, { [k_1 in keyof baseObjectInputType<T>]: baseObjectInputType<T>[k_1]; }>;
    const strictObjectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, "strict", ZodTypeAny, { [k in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T>, any>]: objectUtil.addQuestionMarks<baseObjectOutputType<T>, any>[k]; }, { [k_1 in keyof baseObjectInputType<T>]: baseObjectInputType<T>[k_1]; }>;
    const unionType: <T extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T, params?: RawCreateParams) => ZodUnion<T>;
    const discriminatedUnionType: typeof ZodDiscriminatedUnion.create;
    const intersectionType: <T extends ZodTypeAny, U extends ZodTypeAny>(left: T, right: U, params?: RawCreateParams) => ZodIntersection<T, U>;
    const tupleType: <T extends [] | [ZodTypeAny, ...ZodTypeAny[]]>(schemas: T, params?: RawCreateParams) => ZodTuple<T, null>;
    const recordType: typeof ZodRecord.create;
    const mapType: <Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny>(keyType: Key, valueType: Value, params?: RawCreateParams) => ZodMap<Key, Value>;
    const setType: <Value extends ZodTypeAny = ZodTypeAny>(valueType: Value, params?: RawCreateParams) => ZodSet<Value>;
    const functionType: typeof ZodFunction.create;
    const lazyType: <T extends ZodTypeAny>(getter: () => T, params?: RawCreateParams) => ZodLazy<T>;
    const literalType: <T extends Primitive>(value: T, params?: RawCreateParams) => ZodLiteral<T>;
    const enumType: typeof createZodEnum;
    const nativeEnumType: <T extends EnumLike>(values: T, params?: RawCreateParams) => ZodNativeEnum<T>;
    const promiseType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodPromise<T>;
    const effectsType: <I extends ZodTypeAny>(schema: I, effect: Effect<I["_output"]>, params?: RawCreateParams) => ZodEffects<I, I["_output"], input<I>>;
    const optionalType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodOptional<T>;
    const nullableType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodNullable<T>;
    const preprocessType: <I extends ZodTypeAny>(preprocess: (arg: unknown, ctx: RefinementCtx) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I["_output"], unknown>;
    const pipelineType: typeof ZodPipeline.create;
    const ostring: () => ZodOptional<ZodString>;
    const onumber: () => ZodOptional<ZodNumber>;
    const oboolean: () => ZodOptional<ZodBoolean>;
    const coerce: {
        string: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: true | undefined;
        }) | undefined) => ZodString;
        number: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: boolean | undefined;
        }) | undefined) => ZodNumber;
        boolean: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: boolean | undefined;
        }) | undefined) => ZodBoolean;
        bigint: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: boolean | undefined;
        }) | undefined) => ZodBigInt;
        date: (params?: ({
            errorMap?: ZodErrorMap | undefined;
            invalid_type_error?: string | undefined;
            required_error?: string | undefined;
            message?: string | undefined;
            description?: string | undefined;
        } & {
            coerce?: boolean | undefined;
        }) | undefined) => ZodDate;
    };

    export { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };
    const NEVER: never;
}